[
  {
    "projectId": "b7ea9efb-89a5-4c25-8887-2f280f654f33",
    "testId": "3535cf86-021f-4fea-b912-e1db742624d3",
    "userId": "f498a428-20f1-70a5-3974-bd5750a2ce08",
    "title": "TC001-get_welcome_message",
    "description": "Test the base API endpoint /api/ to verify it returns a welcome message with status 200 and requires Bearer token authentication.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTOKEN = \"6kiK4TxnTZl1uJkBuwso5uJI7bhBxb4s.ecfMkD6%2B5U6S9%2FqfJcuTiLtLeku7hLtpOx1CDqM5l1g%3D\"\nHEADERS = {\n    \"Authorization\": f\"Bearer {TOKEN}\",\n    \"Accept\": \"application/json\"\n}\nTIMEOUT = 30\n\ndef test_get_welcome_message():\n    url = f\"{BASE_URL}/api/\"\n    try:\n        response = requests.get(url, headers=HEADERS, timeout=TIMEOUT)\n        assert response.status_code == 200, f\"Expected 200 but got {response.status_code}\"\n        json_data = response.json()\n        assert isinstance(json_data, dict), \"Response is not a JSON object\"\n        assert \"message\" in json_data, \"Response JSON does not contain 'message' key\"\n        assert isinstance(json_data[\"message\"], str), \"'message' is not a string\"\n        assert len(json_data[\"message\"]) > 0, \"'message' is empty\"\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_get_welcome_message()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-20T21:13:08.906Z",
    "modified": "2025-09-20T21:13:35.161Z"
  },
  {
    "projectId": "b7ea9efb-89a5-4c25-8887-2f280f654f33",
    "testId": "7472fc02-454b-4b81-a6e5-fbfae8b42da0",
    "userId": "f498a428-20f1-70a5-3974-bd5750a2ce08",
    "title": "TC002-create_new_note",
    "description": "Test the POST /api/note/create endpoint to create a new note with valid title and content, ensuring the note is saved with correct user association and timestamps.",
    "code": "import requests\nfrom datetime import datetime\n\nBASE_URL = \"http://localhost:3000\"\nTOKEN = \"6kiK4TxnTZl1uJkBuwso5uJI7bhBxb4s.ecfMkD6%2B5U6S9%2FqfJcuTiLtLeku7hLtpOx1CDqM5l1g%3D\"\nHEADERS = {\n    \"Authorization\": f\"Bearer {TOKEN}\",\n    \"Content-Type\": \"application/json\",\n    \"Accept\": \"application/json\"\n}\nTIMEOUT = 30\n\ndef test_create_new_note():\n    url_create = f\"{BASE_URL}/api/note/create\"\n    url_delete = None\n\n    # Prepare payload for creating a note\n    payload = {\n        \"title\": \"Test Note Title\",\n        \"content\": \"This is a test note content.\"\n    }\n\n    try:\n        # Create a new note\n        response = requests.post(url_create, json=payload, headers=HEADERS, timeout=TIMEOUT)\n        assert response.status_code == 200, f\"Expected 200 OK, got {response.status_code}\"\n        resp_json = response.json()\n        assert isinstance(resp_json, dict), \"Response is not a JSON object\"\n        assert resp_json.get(\"success\") is True, \"Success flag not True in response\"\n        data = resp_json.get(\"data\")\n        assert data is not None and isinstance(data, dict), \"Data field missing or invalid\"\n        note_id = data.get(\"id\")\n        assert isinstance(note_id, str) and note_id, \"Note ID is missing or invalid\"\n        url_delete = f\"{BASE_URL}/api/note/delete/{note_id}\"\n\n        # Validate returned note fields\n        assert data.get(\"title\") == payload[\"title\"], \"Title mismatch in response data\"\n        assert data.get(\"content\") == payload[\"content\"], \"Content mismatch in response data\"\n        user_id = data.get(\"userId\")\n        assert isinstance(user_id, str) and user_id, \"User ID missing or invalid\"\n        \n        # Validate createdAt and updatedAt are ISO 8601 date-time strings and logical\n        created_at_str = data.get(\"createdAt\")\n        updated_at_str = data.get(\"updatedAt\")\n        assert isinstance(created_at_str, str) and created_at_str, \"createdAt missing or invalid\"\n        assert isinstance(updated_at_str, str) and updated_at_str, \"updatedAt missing or invalid\"\n        created_at = datetime.fromisoformat(created_at_str.replace('Z', '+00:00'))\n        updated_at = datetime.fromisoformat(updated_at_str.replace('Z', '+00:00'))\n        assert updated_at >= created_at, \"updatedAt is earlier than createdAt\"\n\n    finally:\n        # Clean up: delete the created note if created\n        if url_delete:\n            try:\n                del_resp = requests.delete(url_delete, headers=HEADERS, timeout=TIMEOUT)\n                assert del_resp.status_code == 200, f\"Failed to delete note after test, status {del_resp.status_code}\"\n            except Exception as e:\n                raise AssertionError(f\"Exception during cleanup deleting note: {e}\")\n\ntest_create_new_note()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-20T21:13:08.911Z",
    "modified": "2025-09-20T21:16:59.647Z"
  },
  {
    "projectId": "b7ea9efb-89a5-4c25-8887-2f280f654f33",
    "testId": "a4c4a762-cb00-467d-aef9-eac1cf27741d",
    "userId": "f498a428-20f1-70a5-3974-bd5750a2ce08",
    "title": "TC003-update_existing_note",
    "description": "Test the PATCH /api/note/update/{id} endpoint to update an existing note's title and/or content, verifying success response and handling of non-existent note with 404.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTOKEN = \"6kiK4TxnTZl1uJkBuwso5uJI7bhBxb4s.ecfMkD6%2B5U6S9%2FqfJcuTiLtLeku7hLtpOx1CDqM5l1g%3D\"\nHEADERS = {\n    \"Authorization\": f\"Bearer {TOKEN}\",\n    \"Content-Type\": \"application/json\"\n}\nTIMEOUT = 30\n\n\ndef test_update_existing_note():\n    note_create_url = f\"{BASE_URL}/api/note/create\"\n    note_update_url_template = f\"{BASE_URL}/api/note/update/{{}}\"\n    note_delete_url_template = f\"{BASE_URL}/api/note/delete/{{}}\"\n\n    created_note_id = None\n    # First, create a note to update\n    create_payload = {\n        \"title\": \"Original Title\",\n        \"content\": \"Original content of the note.\"\n    }\n\n    try:\n        create_resp = requests.post(note_create_url, json=create_payload, headers=HEADERS, timeout=TIMEOUT)\n        assert create_resp.status_code == 200, f\"Note creation failed with status {create_resp.status_code}\"\n        create_data = create_resp.json()\n        assert create_data.get(\"success\") is True, \"Note creation success flag is False\"\n        note_data = create_data.get(\"data\")\n        assert note_data and \"id\" in note_data, \"Created note data missing id\"\n        created_note_id = note_data[\"id\"]\n\n        # Prepare update payload - update both title and content\n        update_payload = {\n            \"title\": \"Updated Title\",\n            \"content\": \"Updated content of the note.\"\n        }\n        update_url = note_update_url_template.format(created_note_id)\n\n        update_resp = requests.patch(update_url, json=update_payload, headers=HEADERS, timeout=TIMEOUT)\n        assert update_resp.status_code == 200, f\"Note update failed with status {update_resp.status_code}\"\n\n        # Verify the update by fetching the note\n        get_note_url = f\"{BASE_URL}/api/note/{created_note_id}\"\n        get_resp = requests.get(get_note_url, headers=HEADERS, timeout=TIMEOUT)\n        assert get_resp.status_code == 200, f\"Getting updated note failed with status {get_resp.status_code}\"\n        note = get_resp.json().get(\"data\")\n        assert note is not None, \"Updated note data missing\"\n        assert note.get(\"title\") == update_payload[\"title\"], \"Note title was not updated correctly\"\n        assert note.get(\"content\") == update_payload[\"content\"], \"Note content was not updated correctly\"\n\n        # Test update on a non-existent note id\n        fake_id = \"nonexistent-note-id-123456\"\n        fake_update_url = note_update_url_template.format(fake_id)\n        fake_update_resp = requests.patch(fake_update_url, json=update_payload, headers=HEADERS, timeout=TIMEOUT)\n        assert fake_update_resp.status_code == 404, f\"Updating non-existent note should return 404 but got {fake_update_resp.status_code}\"\n\n    finally:\n        # Cleanup: delete the created note if it exists\n        if created_note_id:\n            delete_url = note_delete_url_template.format(created_note_id)\n            try:\n                requests.delete(delete_url, headers=HEADERS, timeout=TIMEOUT)\n            except Exception:\n                pass\n\n\ntest_update_existing_note()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-20T21:13:08.915Z",
    "modified": "2025-09-20T21:14:02.883Z"
  },
  {
    "projectId": "b7ea9efb-89a5-4c25-8887-2f280f654f33",
    "testId": "c6e7976d-088f-4c43-9ea6-6353bfc74ce3",
    "userId": "f498a428-20f1-70a5-3974-bd5750a2ce08",
    "title": "TC004-delete_note",
    "description": "Test the DELETE /api/note/delete/{id} endpoint to delete a note by id, verifying successful deletion and 404 response if note does not exist.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTOKEN = \"6kiK4TxnTZl1uJkBuwso5uJI7bhBxb4s.ecfMkD6%2B5U6S9%2FqfJcuTiLtLeku7hLtpOx1CDqM5l1g%3D\"\n\nHEADERS = {\n    \"Authorization\": f\"Bearer {TOKEN}\",\n    \"Content-Type\": \"application/json\"\n}\n\ndef test_delete_note():\n    create_url = f\"{BASE_URL}/api/note/create\"\n    delete_url_template = f\"{BASE_URL}/api/note/delete/{{}}\"\n    get_url_template = f\"{BASE_URL}/api/note/{{}}\"\n    note_payload = {\n        \"title\": \"Temporary Note for Deletion\",\n        \"content\": \"This note is created to test deletion endpoint.\"\n    }\n\n    note_id = None\n    try:\n        # Create a note to delete\n        create_resp = requests.post(create_url, json=note_payload, headers=HEADERS, timeout=30)\n        assert create_resp.status_code == 200, f\"Create note failed with status {create_resp.status_code}\"\n        create_data = create_resp.json()\n        assert create_data.get(\"success\") is True, \"Create note response success flag not True\"\n        note_id = create_data.get(\"data\", {}).get(\"id\")\n        assert note_id, \"Created note ID missing\"\n\n        # Delete the created note\n        delete_url = delete_url_template.format(note_id)\n        delete_resp = requests.delete(delete_url, headers=HEADERS, timeout=30)\n        assert delete_resp.status_code == 200, f\"Delete note failed with status {delete_resp.status_code}\"\n\n        # Verify the note no longer exists (should get 404)\n        get_url = get_url_template.format(note_id)\n        get_resp = requests.get(get_url, headers=HEADERS, timeout=30)\n        assert get_resp.status_code == 404, f\"Expected 404 for deleted note, got {get_resp.status_code}\"\n\n        # Attempt deleting a non-existent note (should get 404)\n        non_existent_id = \"nonexistentid1234567890\"\n        delete_resp_404 = requests.delete(delete_url_template.format(non_existent_id), headers=HEADERS, timeout=30)\n        assert delete_resp_404.status_code == 404, f\"Expected 404 deleting non-existent note, got {delete_resp_404.status_code}\"\n\n    finally:\n        # Cleanup: Just in case the note was not deleted by test\n        if note_id:\n            requests.delete(delete_url_template.format(note_id), headers=HEADERS, timeout=30)\n\ntest_delete_note()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-20T21:13:08.919Z",
    "modified": "2025-09-20T21:17:12.972Z"
  },
  {
    "projectId": "b7ea9efb-89a5-4c25-8887-2f280f654f33",
    "testId": "8000bf2a-9a96-434b-aeff-3aa7ae0d2d1f",
    "userId": "f498a428-20f1-70a5-3974-bd5750a2ce08",
    "title": "TC005-get_all_user_notes_with_pagination",
    "description": "Test the GET /api/note/all endpoint to retrieve all notes for a user with pagination parameters page and limit, verifying correct pagination metadata and note data.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTOKEN = \"6kiK4TxnTZl1uJkBuwso5uJI7bhBxb4s.ecfMkD6%2B5U6S9%2FqfJcuTiLtLeku7hLtpOx1CDqM5l1g%3D\"\nHEADERS = {\n    \"Authorization\": f\"Bearer {TOKEN}\",\n    \"Content-Type\": \"application/json\"\n}\nTIMEOUT = 30\n\n\ndef test_get_all_user_notes_with_pagination():\n    # Step 1: Create multiple notes to ensure pagination data is present\n    created_note_ids = []\n    try:\n        for i in range(25):\n            title = f\"Test Note {uuid.uuid4()}\"\n            content = f\"Content for {title}\"\n            create_resp = requests.post(\n                f\"{BASE_URL}/api/note/create\",\n                json={\"title\": title, \"content\": content},\n                headers=HEADERS,\n                timeout=TIMEOUT\n            )\n            assert create_resp.status_code == 200, f\"Create note failed: {create_resp.text}\"\n            create_data = create_resp.json()\n            assert create_data.get(\"success\") is True, f\"Create note unsuccessful: {create_data}\"\n            note_id = create_data.get(\"data\", {}).get(\"id\")\n            assert note_id, \"No note ID returned on creation\"\n            created_note_ids.append(note_id)\n\n        # Step 2: Retrieve notes with pagination parameters page=1, limit=10\n        params = {\"page\": 1, \"limit\": 10}\n        get_resp = requests.get(\n            f\"{BASE_URL}/api/note/all\",\n            headers=HEADERS,\n            params=params,\n            timeout=TIMEOUT\n        )\n        assert get_resp.status_code == 200, f\"Failed to get notes: {get_resp.text}\"\n        resp_json = get_resp.json()\n\n        # Validate response structure and success flag\n        assert \"success\" in resp_json, \"Missing 'success' in response\"\n        assert resp_json[\"success\"] is True, \"Response success flag is not True\"\n        assert \"data\" in resp_json, \"Missing 'data' in response\"\n        assert isinstance(resp_json[\"data\"], list), \"'data' should be a list\"\n        assert len(resp_json[\"data\"]) <= params[\"limit\"], \"Returned notes exceed limit\"\n\n        # Validate each note object\n        for note in resp_json[\"data\"]:\n            assert isinstance(note, dict), \"Note item is not a dict\"\n            assert \"id\" in note and isinstance(note[\"id\"], str) and note[\"id\"], \"Note missing valid 'id'\"\n            assert \"title\" in note and isinstance(note[\"title\"], str), \"Note missing valid 'title'\"\n            assert \"content\" in note and isinstance(note[\"content\"], str), \"Note missing valid 'content'\"\n            assert \"createdAt\" in note and isinstance(note[\"createdAt\"], str) and note[\"createdAt\"], \"Note missing valid 'createdAt'\"\n\n        # Validate pagination metadata\n        assert \"pagination\" in resp_json, \"Missing pagination metadata\"\n        pagination = resp_json[\"pagination\"]\n        assert isinstance(pagination, dict), \"Pagination is not a dict\"\n        assert \"total\" in pagination and isinstance(pagination[\"total\"], int) and pagination[\"total\"] >= len(created_note_ids), \"Invalid pagination total\"\n        assert \"page\" in pagination and pagination[\"page\"] == params[\"page\"], \"Pagination page mismatch\"\n        assert \"limit\" in pagination and pagination[\"limit\"] == params[\"limit\"], \"Pagination limit mismatch\"\n        assert \"totalPages\" in pagination and isinstance(pagination[\"totalPages\"], int) and pagination[\"totalPages\"] >= 1, \"Invalid totalPages in pagination\"\n\n    finally:\n        # Cleanup: delete created notes\n        for note_id in created_note_ids:\n            try:\n                del_resp = requests.delete(\n                    f\"{BASE_URL}/api/note/delete/{note_id}\",\n                    headers=HEADERS,\n                    timeout=TIMEOUT\n                )\n                # 200 or 404 is acceptable if double delete triggered\n                if del_resp.status_code not in (200, 404):\n                    print(f\"Warning: Unexpected delete status {del_resp.status_code} for note {note_id}\")\n            except Exception as e:\n                print(f\"Exception while deleting note {note_id}: {e}\")\n\n\ntest_get_all_user_notes_with_pagination()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-20T21:13:08.924Z",
    "modified": "2025-09-20T21:16:53.569Z"
  },
  {
    "projectId": "b7ea9efb-89a5-4c25-8887-2f280f654f33",
    "testId": "ebc7dd99-7320-4faf-8015-9687a97a30ec",
    "userId": "f498a428-20f1-70a5-3974-bd5750a2ce08",
    "title": "TC006-get_specific_note_by_id",
    "description": "Test the GET /api/note/{id} endpoint to fetch a specific note by id, verifying successful retrieval and 404 response if note is not found.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTOKEN = \"6kiK4TxnTZl1uJkBuwso5uJI7bhBxb4s.ecfMkD6%2B5U6S9%2FqfJcuTiLtLeku7hLtpOx1CDqM5l1g%3D\"\nHEADERS = {\n    \"Authorization\": f\"Bearer {TOKEN}\",\n    \"Content-Type\": \"application/json\"\n}\nTIMEOUT = 30\n\ndef test_get_specific_note_by_id():\n    # First create a note to have a valid note id\n    create_payload = {\n        \"title\": \"Test Note for TC006\",\n        \"content\": \"This is a test note content for test case TC006.\"\n    }\n    note_id = None\n    try:\n        create_response = requests.post(\n            f\"{BASE_URL}/api/note/create\",\n            json=create_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert create_response.status_code == 200, f\"Expected 200 on note creation, got {create_response.status_code}\"\n        create_json = create_response.json()\n        assert create_json.get(\"success\") is True, \"Note creation success flag is not True\"\n        data = create_json.get(\"data\")\n        assert data is not None, \"No data object in creation response\"\n        note_id = data.get(\"id\")\n        assert isinstance(note_id, str) and len(note_id) > 0, \"Note ID invalid in creation response\"\n\n        # Test successful retrieval of the note by id\n        get_response = requests.get(\n            f\"{BASE_URL}/api/note/{note_id}\",\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert get_response.status_code == 200, f\"Expected 200 when retrieving existing note, got {get_response.status_code}\"\n        get_json = get_response.json()\n        # Check returned note data integrity\n        assert get_json.get(\"id\") == note_id or get_json.get(\"data\", {}).get(\"id\") == note_id or \"data\" in get_json, \\\n            \"Returned note ID does not match requested ID\"\n        # The response schema is not explicitly detailed for GET /api/note/{id} 200, but at least success and note details expected\n        # Validate that required fields exist in response\n        note_data = get_json if \"id\" in get_json else get_json.get(\"data\") if get_json.get(\"data\") else {}\n        assert note_data.get(\"title\") == create_payload[\"title\"], \"Note title mismatch in retrieved data\"\n        assert note_data.get(\"content\") == create_payload[\"content\"], \"Note content mismatch in retrieved data\"\n\n        # Test retrieval of a non-existent note id yields 404\n        fake_id = \"nonexistent-note-id-1234567890\"\n        if fake_id == note_id:\n            fake_id += \"xyz\"  # ensure different\n        not_found_response = requests.get(\n            f\"{BASE_URL}/api/note/{fake_id}\",\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert not_found_response.status_code == 404, f\"Expected 404 when retrieving non-existent note, got {not_found_response.status_code}\"\n\n    finally:\n        # Cleanup: delete the created note if it was created\n        if note_id:\n            try:\n                del_response = requests.delete(\n                    f\"{BASE_URL}/api/note/delete/{note_id}\",\n                    headers=HEADERS,\n                    timeout=TIMEOUT\n                )\n                # Deletion might return 200 if deleted successfully, 404 if already deleted\n                assert del_response.status_code in [200, 404], f\"Unexpected status code on note deletion: {del_response.status_code}\"\n            except Exception:\n                pass\n\ntest_get_specific_note_by_id()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-20T21:13:08.928Z",
    "modified": "2025-09-20T21:17:29.734Z"
  },
  {
    "projectId": "b7ea9efb-89a5-4c25-8887-2f280f654f33",
    "testId": "63c1b1bd-7ffa-4739-b324-c5dc7412741e",
    "userId": "f498a428-20f1-70a5-3974-bd5750a2ce08",
    "title": "TC007-start_or_continue_chat_conversation",
    "description": "Test the POST /api/chat endpoint to start or continue a chat conversation with required fields id, message, and selectedModelId, verifying streaming AI response and handling generation limit reached with 403.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTOKEN = \"6kiK4TxnTZl1uJkBuwso5uJI7bhBxb4s.ecfMkD6%2B5U6S9%2FqfJcuTiLtLeku7hLtpOx1CDqM5l1g%3D\"\nHEADERS = {\n    \"Authorization\": f\"Bearer {TOKEN}\",\n    \"Content-Type\": \"application/json\",\n    \"Accept\": \"application/json\",\n}\nTIMEOUT = 30\n\n\ndef test_start_or_continue_chat_conversation():\n    # Prepare a unique chat ID and request payload\n    chat_id = str(uuid.uuid4())\n    message_payload = {\"text\": \"Hello, AI! Please start the conversation.\"}  # Changed to object\n    selected_model_id = \"default-model\"\n\n    url = f\"{BASE_URL}/api/chat\"\n    payload = {\n        \"id\": chat_id,\n        \"message\": message_payload,\n        \"selectedModelId\": selected_model_id\n    }\n\n    try:\n        # Make the POST request to start or continue the chat conversation\n        response = requests.post(url, json=payload, headers=HEADERS, timeout=TIMEOUT, stream=True)\n\n        # If 403, must be generation limit reached\n        if response.status_code == 403:\n            json_resp = None\n            try:\n                json_resp = response.json()\n            except Exception:\n                pass\n            # Assert error due to generation limit\n            assert json_resp is None or (isinstance(json_resp, dict)), \"403 response should be JSON or empty\"\n            return  # Test passes as 403 is valid error when limit reached\n\n        # For success 200, expect streamed response (likely chunked)\n        assert response.status_code == 200, f\"Expected 200 OK or 403, got {response.status_code}\"\n\n        # Since streaming, we read chunks and accumulate them\n        full_response_text = \"\"\n        for chunk in response.iter_content(chunk_size=1024, decode_unicode=True):\n            if chunk:\n                full_response_text += chunk\n\n        # Basic response validation: must contain some AI generated text as string\n        assert len(full_response_text.strip()) > 0, \"Streaming response should not be empty\"\n\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request failed: {str(e)}\"\n\n\ntest_start_or_continue_chat_conversation()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 58, in <module>\n  File \"<string>\", line 43, in test_start_or_continue_chat_conversation\nAssertionError: Expected 200 OK or 403, got 400\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-20T21:13:08.933Z",
    "modified": "2025-09-20T21:17:55.400Z"
  },
  {
    "projectId": "b7ea9efb-89a5-4c25-8887-2f280f654f33",
    "testId": "fa0d524b-c0a1-43b7-bb6b-4746ceddc046",
    "userId": "f498a428-20f1-70a5-3974-bd5750a2ce08",
    "title": "TC008-get_all_user_chats",
    "description": "Test the GET /api/chat endpoint to retrieve all chat conversations for the authenticated user, verifying the response contains chat list with correct user association.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTOKEN = \"6kiK4TxnTZl1uJkBuwso5uJI7bhBxb4s.ecfMkD6%2B5U6S9%2FqfJcuTiLtLeku7hLtpOx1CDqM5l1g%3D\"\nHEADERS = {\n    \"Authorization\": f\"Bearer {TOKEN}\",\n    \"Accept\": \"application/json\",\n}\n\n\ndef test_get_all_user_chats():\n    url = f\"{BASE_URL}/api/chat\"\n    try:\n        response = requests.get(url, headers=HEADERS, timeout=30)\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200 but got {response.status_code}\"\n\n    json_data = response.json()\n    assert \"success\" in json_data, \"Response JSON missing 'success' key\"\n    assert json_data[\"success\"] is True, \"'success' key should be True\"\n\n    assert \"data\" in json_data, \"Response JSON missing 'data' key\"\n    assert isinstance(json_data[\"data\"], list), \"'data' should be a list\"\n\n    # Verify each chat item has required fields and correct user association (userId is a non-empty string)\n    for chat in json_data[\"data\"]:\n        assert isinstance(chat, dict), \"Each chat item should be a dict\"\n        for field in [\"id\", \"title\", \"userId\", \"createdAt\"]:\n            assert field in chat, f\"Chat item missing '{field}' field\"\n        # userId should be a non-empty string\n        assert isinstance(chat[\"userId\"], str) and chat[\"userId\"], \"'userId' should be a non-empty string\"\n\n\ntest_get_all_user_chats()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-20T21:13:08.937Z",
    "modified": "2025-09-20T21:17:18.443Z"
  },
  {
    "projectId": "b7ea9efb-89a5-4c25-8887-2f280f654f33",
    "testId": "8f7caf93-a594-47d2-a479-172d9c2af0da",
    "userId": "f498a428-20f1-70a5-3974-bd5750a2ce08",
    "title": "TC009-get_specific_chat_with_messages",
    "description": "Test the GET /api/chat/{id} endpoint to fetch a specific chat conversation along with its messages, verifying successful retrieval and correct data structure.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTOKEN = \"6kiK4TxnTZl1uJkBuwso5uJI7bhBxb4s.ecfMkD6%2B5U6S9%2FqfJcuTiLtLeku7hLtpOx1CDqM5l1g%3D\"\nHEADERS = {\n    \"Authorization\": f\"Bearer {TOKEN}\",\n    \"Content-Type\": \"application/json\"\n}\nTIMEOUT = 30\n\n\ndef test_get_specific_chat_with_messages():\n    chat_id = None\n\n    # Create a new chat to get a valid chat id\n    # Per PRD: POST /api/chat - requires id, message, selectedModelId\n    create_chat_url = f\"{BASE_URL}/api/chat\"\n    new_chat_id = str(uuid.uuid4())\n    payload = {\n        \"id\": new_chat_id,\n        \"message\": {\n            \"role\": \"user\",\n            \"content\": \"Hello, this is a test message.\"\n        },\n        \"selectedModelId\": \"test-model-1\"\n    }\n\n    try:\n        # Create chat/conversation\n        create_resp = requests.post(create_chat_url, json=payload, headers=HEADERS, timeout=TIMEOUT)\n        assert create_resp.status_code == 200, f\"Expected 200, got {create_resp.status_code}\"\n        # The chat id is the one we sent \"id\" in payload\n        chat_id = new_chat_id\n\n        # Now get the specific chat with messages\n        get_chat_url = f\"{BASE_URL}/api/chat/{chat_id}\"\n        get_resp = requests.get(get_chat_url, headers=HEADERS, timeout=TIMEOUT)\n        assert get_resp.status_code == 200, f\"Expected 200, got {get_resp.status_code}\"\n        data = get_resp.json()\n        # Based on description, expecting a chat object with messages\n        # Basic checks for structure\n        assert isinstance(data, dict), \"Response JSON should be an object\"\n        # Expect containing keys relevant to chat and messages\n        # Since schema is not explicit, check for 'id' and 'messages' key presence\n        assert \"id\" in data, \"'id' field missing in chat data\"\n        assert data[\"id\"] == chat_id, \"Returned chat id does not match requested id\"\n        assert \"messages\" in data, \"'messages' field missing in chat data\"\n        assert isinstance(data[\"messages\"], list), \"'messages' should be a list\"\n        # If there are messages, check structure of the first message\n        if data[\"messages\"]:\n            first_msg = data[\"messages\"][0]\n            assert isinstance(first_msg, dict), \"Each message should be an object\"\n            assert \"role\" in first_msg, \"Message missing 'role' field\"\n            assert \"content\" in first_msg, \"Message missing 'content' field\"\n\n    finally:\n        # Cleanup: Delete the created chat if API supports deletion of chat\n        # The PRD does not specify chat delete, so skip delete cleanup\n        # If chat delete endpoint existed, we'd call it here\n        pass\n\n\ntest_get_specific_chat_with_messages()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 64, in <module>\n  File \"<string>\", line 32, in test_get_specific_chat_with_messages\nAssertionError: Expected 200, got 400\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-20T21:13:08.942Z",
    "modified": "2025-09-20T21:17:42.123Z"
  },
  {
    "projectId": "b7ea9efb-89a5-4c25-8887-2f280f654f33",
    "testId": "631d2df0-7675-4969-b65d-cb799b2f9e21",
    "userId": "f498a428-20f1-70a5-3974-bd5750a2ce08",
    "title": "TC010-upgrade_user_subscription_plan",
    "description": "Test the POST /api/subscription/upgrade endpoint to upgrade the user's subscription plan to plus or premium, verifying checkout URL generation and handling already on requested plan with 400.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTOKEN = \"6kiK4TxnTZl1uJkBuwso5uJI7bhBxb4s.ecfMkD6%2B5U6S9%2FqfJcuTiLtLeku7hLtpOx1CDqM5l1g%3D\"\nHEADERS = {\n    \"Authorization\": f\"Bearer {TOKEN}\",\n    \"Content-Type\": \"application/json\"\n}\nTIMEOUT = 30\n\n\ndef test_upgrade_user_subscription_plan():\n    url = f\"{BASE_URL}/api/subscription/upgrade\"\n    callback_url = \"http://localhost/success\"\n\n    # Test upgrading to 'plus' plan\n    payload_plus = {\n        \"plan\": \"plus\",\n        \"callbackUrl\": callback_url\n    }\n    response_plus = requests.post(url, headers=HEADERS, json=payload_plus, timeout=TIMEOUT)\n    # Allow either success (200) or error 400 if already on plan\n    assert response_plus.status_code in (200, 400), f\"Unexpected status code for plus plan: {response_plus.status_code}\"\n    if response_plus.status_code == 200:\n        body = response_plus.json()\n        assert isinstance(body, dict), \"Response is not a JSON object\"\n        assert \"success\" in body and isinstance(body[\"success\"], bool), \"'success' missing or not boolean\"\n        assert body[\"success\"] is True, \"'success' should be True for 200 response\"\n        assert \"checkoutUrl\" in body and isinstance(body[\"checkoutUrl\"], str) and body[\"checkoutUrl\"].strip() != \"\", \"'checkoutUrl' missing or empty\"\n    else:\n        # 400 case: check message or just pass\n        pass\n\n    # Test upgrading to 'premium' plan\n    payload_premium = {\n        \"plan\": \"premium\",\n        \"callbackUrl\": callback_url\n    }\n    response_premium = requests.post(url, headers=HEADERS, json=payload_premium, timeout=TIMEOUT)\n    assert response_premium.status_code in (200, 400), f\"Unexpected status code for premium plan: {response_premium.status_code}\"\n    if response_premium.status_code == 200:\n        body = response_premium.json()\n        assert isinstance(body, dict), \"Response is not a JSON object\"\n        assert \"success\" in body and isinstance(body[\"success\"], bool), \"'success' missing or not boolean\"\n        assert body[\"success\"] is True, \"'success' should be True for 200 response\"\n        assert \"checkoutUrl\" in body and isinstance(body[\"checkoutUrl\"], str) and body[\"checkoutUrl\"].strip() != \"\", \"'checkoutUrl' missing or empty\"\n    else:\n        # 400 case: check message or just pass\n        pass\n\n\ntest_upgrade_user_subscription_plan()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 52, in <module>\n  File \"<string>\", line 23, in test_upgrade_user_subscription_plan\nAssertionError: Unexpected status code for plus plan: 500\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-20T21:13:08.948Z",
    "modified": "2025-09-20T21:18:07.910Z"
  }
]
